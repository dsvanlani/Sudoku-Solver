[{"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/reportWebVitals.js":"1","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/App.js":"2","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/components/Tile.js":"3","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/components/Board.js":"4","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/components/CheckSolutionButton.js":"5","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/checkIDs.js":"6","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/dummyBoard.js":"7","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/index.js":"8","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/utils/get3by3.js":"9","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/utils/getRow.js":"10","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/getBoard.js":"11","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/utils/sleep.js":"12","/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/utils/getColumn.js":"13"},{"size":362,"mtime":1606432237978,"results":"14","hashOfConfig":"15"},{"size":160,"mtime":1606432865258,"results":"16","hashOfConfig":"15"},{"size":413,"mtime":1606446471105,"results":"17","hashOfConfig":"15"},{"size":9285,"mtime":1606606019033,"results":"18","hashOfConfig":"15"},{"size":296,"mtime":1606447225632,"results":"19","hashOfConfig":"15"},{"size":986,"mtime":1606450683789,"results":"20","hashOfConfig":"15"},{"size":675,"mtime":1606495312097,"results":"21","hashOfConfig":"15"},{"size":500,"mtime":1606432237976,"results":"22","hashOfConfig":"15"},{"size":618,"mtime":1606589150491,"results":"23","hashOfConfig":"15"},{"size":604,"mtime":1606588802905,"results":"24","hashOfConfig":"15"},{"size":615,"mtime":1606584483388,"results":"25","hashOfConfig":"15"},{"size":108,"mtime":1606600483960,"results":"26","hashOfConfig":"15"},{"size":601,"mtime":1606593228471,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"1y7mwy4",{"filePath":"31","messages":"32","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"34"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"37"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"41"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"41"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"41"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"41"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"41"},"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/reportWebVitals.js",[],["61","62"],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/App.js",["63"],"import logo from './logo.svg';\nimport './App.css';\nimport Board from './components/Board'\n\nfunction App() {\n  return (\n    <Board />\n  )\n}\n\nexport default App;\n",["64","65"],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/components/Tile.js",[],["66","67"],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/components/Board.js",["68","69"],"import React from 'react'\nimport Tile from './Tile'\nimport getBoard from '../getBoard'\nimport CheckSolutionButton from './CheckSolutionButton'\nimport checkIDs from '../checkIDs'\nimport getRow from '../utils/getRow'\nimport getColumn from '../utils/getColumn'\nimport get3by3 from '../utils/get3by3'\nimport sleep from '../utils/sleep'\n\nclass Board extends React.Component {\n    constructor() {\n        super()\n        const boardValues = getBoard()\n        const initTiles = boardValues.map(k => {  // creates an array of objects of length 81\n            return {                             // to represent the tiles on the board\n                value: k,\n                isInitial: !!k \n            }\n        })\n        this.state = {\n            initTiles: initTiles,\n            tiles: initTiles,\n            selectedTile: null,\n            isSolved: false,\n            step: 0,\n            history: [initTiles]\n        }\n    }\n\n    handleClick(id) {\n        // Changes the selectedTile value in state\n        const selectedTile = id\n        this.setState({\n            ...this.state,\n            selectedTile: selectedTile,\n        })\n    }\n\n    handleKeyDown(event) {\n        const numbers = ['1','2','3','4','5','6','7','8','9']\n        if (this.state.tiles[this.state.selectedTile] && !this.state.tiles[this.state.selectedTile].isInitial ) {\n            if (numbers.includes(event.key)) {  // if the key down was a number\n                const targetTile = this.state.selectedTile   // get the target tile from state\n                let updatedTiles = [...this.state.tiles]     // copy the state of tiles\n                updatedTiles[targetTile] = {                 // change the value of the target tile\n                    value: parseInt(event.key),\n                }\n                this.setState({\n                    ...this.state,\n                    tiles: updatedTiles,\n                    step: this.state.step + 1,\n                    history: this.state.history.concat([updatedTiles])\n                })\n            }      \n        }\n    }\n\n    getValues(idArray) {\n        /* Takes in an array of the id's to check,\n            returns an array of values from said ids */\n\n        const valuesList = []\n        for (let i=0; i < idArray.length; i++) {\n            valuesList.push(this.state.tiles[idArray[i]].value)\n        }\n        return valuesList\n    }\n\n    checkValidity(valuesArray) {\n        /* Takes in an array of Values and returns true\n            or false depending on if each number between\n            1 and 9 is represented once and only once */\n            let checkNumbers = [1,2,3,4,5,6,7,8,9]\n\n            for (let i=0; i< checkNumbers.length; i++) {\n                var num = checkNumbers.pop()         // get a number from the list -\n                if (!valuesArray.includes(num)) {    // if its not in the set of values, return false\n                    return false\n                }\n            }\n            return true                            // return true if you never had to return false\n    }\n\n    handleCheckSolution() {\n        let checks = []\n        for (let i=0; i < checkIDs.length; i++) {   // This creates an array filled with the outcomes to\n            let set = this.getValues(checkIDs[i])   // each of the checks [true,true,false,true... ] etc.\n            checks.push(this.checkValidity(set))\n        }\n\n        if (!checks.includes(false)) {               // If none of them failed, set the state to solved\n            const tempState = this.state\n            tempState.isSolved = true\n            this.setState(tempState)\n        }\n    }\n\n    handleBack() {\n        if (this.state.step != 0) {\n            const currentStep = this.state.step                           // get current step\n            const newTiles = this.state.history[currentStep-1]            // get the tiles for the previous step in history\n            const newHistory = this.state.history.slice(0, currentStep)   // make the history forget that last step\n            this.setState({\n            ...this.state,\n            tiles: newTiles,\n            history: newHistory,\n            step: currentStep - 1\n        })\n\n        }\n        \n    }\n\n    isTerminus(tiles) {\n        for (let i=0; i < 81; i++) {\n            if (tiles[i].value === null) {\n                return false\n            }\n        }\n        return true\n    }\n    \n    isSolution() {\n        let checks = []\n        for (let i=0; i < checkIDs.length; i++) {   // This creates an array filled with the outcomes to\n            let set = this.getValues(checkIDs[i])   // each of the checks [true,true,false,true... ] etc.\n            checks.push(this.checkValidity(set))\n        }\n\n        if (checks.includes(false)) {\n            return false\n        } else {\n            return true\n         }\n    }\n\n    async handleSolve() {\n        let currentTiles = this.state.initTiles\n        let frontier = []\n        \n        while (true) {\n            /* First, check that the tile configuration is a solution, if so\n            change the state of the board to solved */\n            if (this.isTerminus(currentTiles) && this.isSolution(currentTiles)) {\n                break\n            }\n            \n             /* Next get all the possible actions for the current tile configuration */\n            let actions = this.getActions(currentTiles)\n            /* For each action get add the result to the frontier */\n            for (let i=0; i < actions.length; i++) {\n                let action = actions[i]\n                let result = this.getResult(currentTiles, action)\n                frontier.push(result)\n                }   \n            \n                await new Promise(r => setTimeout(r, 50));\n\n            /* set the new tile configuration to the last item in the frontier */\n            currentTiles = frontier.pop()\n            this.setState({\n                ...this.state,\n                tiles: currentTiles\n            })\n        }\n\n        this.setState({\n            ...this.state,\n            isSolved: true,\n            tiles: currentTiles\n        })\n    }\n\n    getPossibleValues(id, tiles) {\n        /* takes in a tile id and a tile configuration and returns an array of\n            legal values on that tile */\n        let tilesToCheck = []\n        let excludedValues = []\n        let possibleValues = []\n\n        tilesToCheck = tilesToCheck.concat(getRow(id), getColumn(id), get3by3(id))\n\n        for (let i=0; i < tilesToCheck.length; i++) {\n            let tile = tiles[tilesToCheck[i]]\n            if (!!tile.value) {\n                excludedValues.push(tile.value)\n            }\n        }\n\n        for (let i=1; i < 10; i++) {\n            if (!excludedValues.includes(i)) {\n                possibleValues.push(i)\n            }\n        }\n        return possibleValues\n    }\n\n    getActions(tiles) {\n        /* this takes in an array of tile objects and returns an array of \"action objects\"\n        which look like this:\n        action = {\n            tileID: <id of the tile>,\n            value: <possible value>\n        } */\n\n        // find the first open square\n        let firstOpenTile = null\n        let firstOpenTileFound = false\n        let actions = []\n\n        while (!firstOpenTileFound) {\n            for (let i=0; i<81; i++) {\n                if (tiles[80-i].value == null) {\n                    firstOpenTile = 80-i\n                    firstOpenTileFound = true\n                }\n            }\n        }\n\n        const possibleValues = this.getPossibleValues(firstOpenTile, tiles)\n\n        for (let i = 0; i<possibleValues.length; i++) {\n            let actionObject = {\n                tileID: firstOpenTile,\n                value: possibleValues[i]\n            }\n            actions.push(actionObject)\n        }\n        \n        return actions\n    }\n\n    getResult(tiles, action) {\n        /* takes in tiles as the tile configuration, and an action object and returns the\n        resulting tile configuration */\n        \n        const tileID = action.tileID\n        const value = action.value\n\n        let newTiles = tiles.slice()\n        newTiles[tileID] = {\n            value: value,\n            isInitial: false\n        }\n        \n        return newTiles\n    }\n\n\n    /* Render Method */\n    render() {\n        const board = this.state.tiles.map((tile, i) => \n            <Tile \n                key={i}\n                value={tile.value}\n                isInitial={tile.isInitial}\n                onClick={() => this.handleClick(i)}\n                />\n        )   \n        \n        return(\n            <div \n            className='board'\n            onKeyDown={e => this.handleKeyDown(e)}>\n                {board}\n                <CheckSolutionButton\n                    onClick={() => this.handleCheckSolution()} />\n                <button \n                className=\"toggleHistoryButton\"\n                onClick={() => this.handleBack()}>\n                    Undo\n                </button>\n                <button\n                id=\"solveButton\"\n                onClick={() => this.handleSolve()}>\n                Solve\n                </button>\n                <span id=\"solvedSpan\">\n                    {this.state.isSolved ? \"Correct Solution\":\"\"}\n                </span>\n            </div>\n        )\n    }\n}\n\n\nexport default Board",["70","71"],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/components/CheckSolutionButton.js",[],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/checkIDs.js",[],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/dummyBoard.js",[],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/index.js",[],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/utils/get3by3.js",[],["72","73"],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/utils/getRow.js",[],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/getBoard.js",[],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/utils/sleep.js",[],"/Users/dvanlani/Library/React Projects/sudoku/sudoku/src/utils/getColumn.js",[],{"ruleId":"74","replacedBy":"75"},{"ruleId":"76","replacedBy":"77"},{"ruleId":"78","severity":1,"message":"79","line":1,"column":8,"nodeType":"80","messageId":"81","endLine":1,"endColumn":12},{"ruleId":"74","replacedBy":"82"},{"ruleId":"76","replacedBy":"83"},{"ruleId":"74","replacedBy":"84"},{"ruleId":"76","replacedBy":"85"},{"ruleId":"78","severity":1,"message":"86","line":9,"column":8,"nodeType":"80","messageId":"81","endLine":9,"endColumn":13},{"ruleId":"87","severity":1,"message":"88","line":100,"column":29,"nodeType":"89","messageId":"90","endLine":100,"endColumn":31},{"ruleId":"74","replacedBy":"91"},{"ruleId":"76","replacedBy":"92"},{"ruleId":"74","replacedBy":"93"},{"ruleId":"76","replacedBy":"94"},"no-native-reassign",["95"],"no-negated-in-lhs",["96"],"no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar",["95"],["96"],["95"],["96"],"'sleep' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected",["95"],["96"],["95"],["96"],"no-global-assign","no-unsafe-negation"]